// Hint files help the Visual Studio IDE interpret Visual C++ identifiers
// such as names of functions and macros.
// For more information see https://go.microsoft.com/fwlink/?linkid=865984
#define AbstractClassInfo(TYPE, PARENT) Entity::ClassInfo TYPE::m_sClass(#TYPE, &PARENT::m_sClass);
#define ConcreteClassInfo(TYPE, PARENT, BLOCKCOUNT) Entity::ClassInfo TYPE::m_sClass(#TYPE, &PARENT::m_sClass, TYPE::Allocate, TYPE::Deallocate, TYPE::NewInstance, BLOCKCOUNT);
#define ClassInfoGetters const Entity::ClassInfo & GetClass() const { return m_sClass; } const std::string & GetClassName() const { return m_sClass.GetName(); }
#define EntityAllocation(TYPE) static void * operator new (size_t size) { return TYPE::m_sClass.GetPoolMemory(); } static void operator delete (void *instance) { TYPE::m_sClass.ReturnPoolMemory(instance); } static void * operator new (size_t size, void *p) throw() { return p; } static void operator delete (void *, void *) throw() { } static void * Allocate() { return malloc(sizeof(TYPE)); } static void Deallocate(void *instance) { free(instance); } static Entity * NewInstance() { return new TYPE; } Entity * Clone(Entity *cloneTo = nullptr) const override { TYPE *ent = cloneTo ? dynamic_cast<TYPE *>(cloneTo) : new TYPE(); RTEAssert(ent, "Tried to clone to an incompatible instance!"); if (cloneTo) { ent->Destroy(); } ent->Create(*this); return ent; }
#define ScriptFunctionNames(__VA_ARGS__) virtual std::vector<std::string> GetSupportedScriptFunctionNames() const { return {__VA_ARGS__}; }
#define AddScriptFunctionNames(PARENT, __VA_ARGS__) std::vector<std::string> GetSupportedScriptFunctionNames() const override { std::vector<std::string> functionNames = PARENT::GetSupportedScriptFunctionNames(); functionNames.insert(functionNames.end(), {__VA_ARGS__}); return functionNames; }
#define SerializableOverrideMethods int ReadProperty(const std::string_view &propName, Reader &reader) override; int Save(Writer &writer) const override;
#define SerializableClassNameGetter const std::string & GetClassName() const override { return c_ClassName; }
#define LuaBindingRegisterFunctionDeclarationForType(TYPENAME) static luabind::scope Register##TYPENAME##LuaBindings();
#define LuaBindingRegisterFunctionDefinitionForType(OWNINGSCOPENAME, TYPENAME) luabind::scope OWNINGSCOPENAME##::Register##TYPENAME##LuaBindings()
#define AbstractTypeLuaClassDefinition(TYPE, PARENTTYPE) luabind::class_<TYPE, PARENTTYPE>(#TYPE) .property("ClassName", &TYPE::GetClassName)
#define ConcreteTypeLuaClassDefinition(TYPE, PARENTTYPE) luabind::class_<TYPE, PARENTTYPE>(#TYPE) .def("Clone", &Clone##TYPE, luabind::adopt(luabind::result)) .property("ClassName", &TYPE::GetClassName)
#define RegisterLuaBindingsOfAbstractType(OWNINGSCOPENAME, TYPE) luabind::def((std::string("To") + std::string(#TYPE)).c_str(), (TYPE *(*)(Entity *))&To##TYPE), luabind::def((std::string("To") + std::string(#TYPE)).c_str(), (const TYPE *(*)(const Entity *))&ToConst##TYPE), OWNINGSCOPENAME##::Register##TYPE##LuaBindings()
#define RegisterLuaBindingsOfConcreteType(OWNINGSCOPENAME, TYPE) luabind::def((std::string("Create") + std::string(#TYPE)).c_str(), (TYPE *(*)(std::string, std::string))&Create##TYPE, luabind::adopt(luabind::result)), luabind::def((std::string("Create") + std::string(#TYPE)).c_str(), (TYPE *(*)(std::string))&Create##TYPE, luabind::adopt(luabind::result)), luabind::def((std::string("Random") + std::string(#TYPE)).c_str(), (TYPE *(*)(std::string, int))&Random##TYPE, luabind::adopt(luabind::result)), luabind::def((std::string("Random") + std::string(#TYPE)).c_str(), (TYPE *(*)(std::string, std::string))&Random##TYPE, luabind::adopt(luabind::result)), luabind::def((std::string("Random") + std::string(#TYPE)).c_str(), (TYPE *(*)(std::string))&Random##TYPE, luabind::adopt(luabind::result)), luabind::def((std::string("To") + std::string(#TYPE)).c_str(), (TYPE *(*)(Entity *))&To##TYPE), luabind::def((std::string("To") + std::string(#TYPE)).c_str(), (const TYPE *(*)(const Entity *))&ToConst##TYPE), luabind::def((std::string("Is") + std::string(#TYPE)).c_str(), (bool(*)(const Entity *))&Is##TYPE), OWNINGSCOPENAME##::Register##TYPE##LuaBindings()